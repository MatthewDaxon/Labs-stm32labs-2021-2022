:imagesdir: Image22
:toc:
:toc-title: Оглавление
= Курсовая работа

== Задание к курсовой работе
Выполнено студентами: Мисюрев А.И. , Васильев М.Д.


image::ТЗ_1.PNG[canvas, size=cover]
image::ТЗ_2.PNG[canvas, size=cover]
image::ТЗ_3.PNG[canvas, size=cover]

== 1) Анализ требований

=== 1.1) Переменный резистор

Переменный резистор (или потенциометр) - это резистор, у которого электрическое сопротивление между подвижным контактом
и выводами резистивного элемента можно изменять механическим способом.

Снимаемое с подвижного отводного контакта потенциометра напряжение может изменяться от нуля до максимального значения,
равного приложенному к потенциометру напряжению, в зависимости от текущего положения подвижного контакта.

Величина снимаемого напряжения может как линейно зависеть от перемещения движка, так и логарифмически, поэтому
потенциометры подразделяются на линейные и логарифмические.

image::ПЕРЕ_РЕЗ.PNG[]
Рисунок 1 -- Схема работы переменного резистора

image::ПЕРЕ_РЕЗ_2.PNG[]
Рисунок 2 -- Схема потенциомента в отладочной плате STM32F411RE

Мультиметром измерим напряжение подаваемое на переменный резистор. И зная что АЦП преобразовывает
в цифрой вид от 1 до 4095, ТО получим уравнение представленное ниже:

U = buf*v/4095,

где, buf -- оцифровонное значение напряжения с АЦП;
     v -- напряжение подаваемое на переменный резистор.

=== 1.2) Температурный сенсор

Датчик температуры используется для измерения температуры окружающей среды устройства.
На рис. 3 показана блок-схема датчика температуры.

Примечание. Бит TSVREFE должен быть установлен, чтобы разрешить преобразование обоих внутренних каналов:
ADC1_IN16 или ADC1_IN18 (датчик температуры).
Основные характеристики:
• Поддерживаемый диапазон температур: от –40 до 125 °C.
• Точность: ±1,5 °C


image::ТЕМП_СЕН.PNG[]
Рисунок 3 -- Блок-схема температурного сенсара

Выход температурного сенсора так же будет обрабатывать АЦП и
получать цифоровые данные. И по формуле представленной ниже
будет расчитывать значение температуры.

T = buf *k+b,

где, buf -- оцифровонное значение температуры с АЦП;

k = 25-0.76/0.0025;

b = 3.3*0.0025/4095;

Все необходимые неизвестные были взяты из даташита на температурный сенсор.

=== 1.3) Аналого-цифровой преобразователь

Аналого-цифровой преобразователь – устройство, которое принимает аналоговые сигналы и генерирует соответствующий им
цифровой код, пригодный для дальнейшей обработки микропроцессором или другим цифровым устройством.

Сперва АЦП преобразует аналоговый сигнал в дискретный, чтобы разбить измеряемый диапазон на какое-то конечное
количество значений. Такой процесс называется квантованием.

Основными характеристиками АЦП можно назвать частоту преобразования, которая выражается в отсчетах в секунду (samples
per second) и разрядность (количество шагов) – в битах.


Почти во всех микроконтроллерах STM32, АЦП выполнено по схеме 12-битного АЦП последовательного приближения
(SAR ADC), структурная схема которая показана на рисунке 4.

image::ТЕМП_СЕН_2.PNG[]
Рисунок 4 -- Структурная схема АЦП

Он включает в себя:

-- Компаратор, регистр последовательного приближения (SAR), цифро-аналоговый преобразователь (ЦАП).

-- Регистр последовательного приближения осуществляет алгоритм последовательного приближения, генерируя текущее значение
кода, подающегося на вход ЦАП, на основе которого ЦАП генерирует выходное напряжение.

-- Компаратор сравнивает значение входного сигнала с сигналом выхода ЦАП. Данный вид преобразователя измеряет величину
входного сигнала, осуществляя ряд последовательных «взвешиваний» (сравнений) измеряемой величины с 1/2, 1/4, 1/8, и
т.д. от ее возможного максимального значения.

-- Допустим, что сигнал находится в интервале (0 – Uоп), тогда с приходом первого тактового импульса регистра
последовательного приближения на выходе встроенного ЦАП устанавливается величина, равная половине Uоп. Если сигнал
превышает эту величину, тогда его сравнивают с напряжением 3/4 Uоп, которое находится посередине оставшегося интервала.
Если сигнал меньше установленного уровня, то следующее сравнение будет производиться с меньшей половиной оставшегося
интервала (т.е. с уровнем 1/4 Uоп). Такое сравнение повторяется N раз и на выходе получается N бит результата.

Основные параметры АЦП, используемого в данной работе:

-- Напряжение питания: Vdd = 1.7 - 3.6 В (стндартное значение Vdd = 3.3 В);

-- Опорное напряжение: Vref = 1.7 - Vdd;

image::АЦП.PNG[]
Рисунок 5 -- Процесс квантования аналогового сигнала

=== 1.4) Прямой доступ к памяти (DMA)

Прямой доступ к памяти (DMA) используется для обеспечения высокоскоростной передачи данных между периферийными
устройствами и памятью.

Каждая передача DMA состоит из трех операций:

--Загрузка данных из регистра периферийного модуля или адреса в памяти через внутренний регистр.

--Сохранение данных, загруженных во внутренний регистр в указанное место. Им может быть периферийный модуль или адрес
в памяти.

--Увеличение адресов источника и приемника при необходимости.

Наше устройство оснащено двумя двухпортовыми DMA общего назначения (DMA1 и DMA2) с 8 каналами каждый. Оба канала
DMA сидят на шине AHB1 и перед тем как начать с ним работать надо на него подать тактирование, подняв бит
DMA2EN в регистре RCC_AHB1ENR

image::RCC.PNG[]

Затем, после подачи тактирования необходимо выбрать канал, которому соответствует АЦП. Согласно
рисунку 6 это канал 0 и поток 0 периферии DMA2.

image::DMA_CH.PNG[]
Рисунок 6 -- Каналы в DMA2

Выбор канала с помощью регистра CR в нем CHSEL.

image::DMA_CR.PNG[]

Следующим шагом копируем данные из АЦП путем подключения регистра PAR.

image::DMA_PAR.PNG[]

Затем необходимо задать адрес буфера, куда копируем данные с помощью регистра M0AR.

image::DMA_M0AR.PNG[]

В регистре NDTR выставляем на выполнение 2 транзакций, для напряжения и темпеартуры.

image::DMA_NDTR.PNG[]

В регистре CR:

image::DMA_CR__.PNG[]

Отключаем режим FIFO в регистре FCR.

image::DMA_FCR.PNG[]

-- Определяем направление передачи данных в DIR.
В нашем случае из периферии в память.

-- Не изменяем адрес периферии, всё время копируем только из ADC1.
Для этого используем PINC.

-- Адрес памяти изменяем, чтобы каждое новое значение записывалось в следующий элемент массива буфера.
Делаем это в MINC.

-- Устанавливаем размер данных буфера 16 бит в MSIZE.

-- Затем можно включить циклический режим, т.е. после того как буфер наполнится, он продолжит наполняться с первого
элемента, естественно старые данные затрутся. В CIRC.

-- Устанавливаем высокий приоритет в PL.

-- Устанавливаем размер данных перифирии 16 бит в PSIZE.

-- Устанавливаем пакетную пересылку по памяти и по периферии в одиночный Single режим в MBURST и PBURST.

-- После всей настройи, запускаем DMA в EN.

=== 1.5) Цифровые фильтры

В задании нужно реализовать фильтр с бесконечной импульсной характеристикой (БИХ) для напряжения и температуры,
для которых создаем новые классы с входной и выходной величиной.

Фильтры с бесконечной импульсной характеристикой (БИХ) относятся к рекурсивным фильтрам и вычисляют выходной
сигнал на основании значений предыдущих входных и выходных отсчётов. Теоретически, импульсная характеристика
БИХ-фильтра никогда не достигает нуля, поэтому выход получается бесконечным по длительности.

Вид БИХ фильтра для температуры:

image::Фил_Тем.PNG[]

Вид БИХ фильтра для напряжения:

image::Фил_Напр.PNG[]

где, а -- коэффициент фильтрации.

=== 1.6) Операционные системы реального времени

*Операционные системы реального времени* (ОСРВ) предназначены для обеспечения интерфейса к ресурсам критических
по времени систем реального времени. Основной задачей в таких системах является своевременность (timeliness)
выполнения обработки данных.

Задачей ОСРВ является обеспечение реакции на определенное действие за отведенный квант времени. Для разных задач этот
квант имеет разное значение.

Например:

-- математическое моделирование - несколько микросекунд;

-- радиолокация - несколько миллисекунд;

-- управление производством - несколько минут.

Временем реакции систем на события называют интервал времени от события на объекте и до выполнения первой интструкции
в программе обработки этого события.

Интервал времени считают от возникновения запроса на прерывание и до выполнения первой инструкции обработчика.
Определяется свойствами операционной системы и архитектурой микроконтроллера.

ОСРВ применяют в случаях:

...если есть устройство с нетривиальной логикой синхронизации обмена данными между набором сенсоров;

...если нужно гарантировать время отклика.

ОСРВ не нужно применять в случае, если задача слишком тривиальна (например, получение данных с 1 сенсора,
и отправлять дальше, обработать нажатие 1 кнопки и т.д.) т.к. это приведет к ненужной избыточности, как полученного
кода, так и решения самой задачи.

Еще одной задачей ОСРВ является многозадачность.

Многозадачность - одновременное выполнение нескольких задач.

Существует несколько видов многозадачности:

-- Кооперативная - следующая задача не выполнится, пока полностью не завершена предыдущая;

-- Вытесняющая - более высоко-приоритетная задача может вытеснить менее приоритетную.

Принцип работы и запуска задачи похож на принцип работы прерывания (рисунок 7).

image::ОСВР.PNG[]
Рисунок 7 -- Принцип работы прерывания.

В ОСРВ вместо прерываний используются задачи, которые вызываются планировщиком каждый раз по прерыванию
системного таймера или при вызове планировщика.

Задача - это минипрограмма, которая имеет свою точку входа, и выполняется внутри бесконечного цикла и обычно не
должна выходить из него. Она имеет собственный стек, приоритет, также может иметь название и идентификатор.

Что можно сделать с задачей:

* можно создать;

* можно удалить;

* можно оповестить;

* активировать/деактивировать;

* перевести в режим ожидания.

image::ОСВР_2.PNG[]
Рисунок 8 -- Принцип работы задач ОСРВ

Free RTOS -- многозадачная операционная система реального времени для встраиваемых систем.
Портирована на 35 микропроцессорных архитектур.
Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и
невытесняющую многозадачность, семафоры и очереди.

Free RTOS мала и проста. Ядро системы умещается в 3-4 файлах.

С помощью данной системы будут созданы задачи.

== 2) Архитектура программы

image::АРХ_1.PNG[canvas, size=cover]
image::АРХ_2.PNG[canvas, size=cover]

Рисунок 9 -- Архитектура программы

Аналоговое напряжение потенциометра и аналоговое напряжение с температурного сенсара поступает на вход АЦП, поэтому
мы используем класс *ADC*, чтобы преобразовать аналоговый сигнал в цифровой код.

Класс *DMA* используется для того, чтобы брать код АЦП без участия процессора и записывать его в буфер.

Значение кода из буфера класса АЦП поступает в класс *Voltage* и там происходит преобразование кода в напряжение а так же
в класс *Temper* и там происходит преобразование кода в температуру.

В класс *FilterForVolt* поступает значение напряжения из класса Voltage.  А так же в класс *FilterForTemp* поступает
значение температуры из класса Temper. В них происходит обработка согласно цифровым фильтрам представленным в ТЗ.

Класс задачи *SendMessageTask* служит для связи всех классов, в котором будет реализована ОСРВ, а так же за прием/передачу
информации с USART.

Класс *FloatToString* принимает значение напряжения или температуру и преобразовывает его в строку с
требуемым количеством знаков после запятой.

Класс *USART* служит настройкой периферии USART.

== 3) Описание классов

=== 3.1) DMA

image::DMA_схема.PNG[]
Рисунок 10 -- Архитектура класса DMA

В данном классе создан метод Setup(), который настраивает перифирию.

=== 3.2) ADC

image::ADC_схема.PNG[]
Рисунок 11 -- Архитектура класса ADC

Метод класса ADC Setup() настраивает периферию ADC. Метод
convertionNumber() запускает преобразование периферии АЦП.
В конструктор приходит ссылка на объект класса DMA и затем в
методе Setup() запускается метод класса dma. В буфере хранится
код полученный с АЦП.

Настройка АЦП:

-- В регистре CR1:

image::ADC_CR1.PNG[]

Для непрерывного преобразования выставляем бит в RES.

Включаем сканирование каналов в SCAN.

-- В регистре CR1:

image::ADC_CR2.PNG[]

Для непрерывного преобразования выставляем бит в CONT.

Включаем режим DMA. И запрос преобразований DMA в DDS.

Включаем АЦП в ADON.

И запускаем преобразование на регулярном канале в SWSTART.

-- В регистре SMPR1:

image::ADC_SMPR1.PNG[]

В SMP18 установка частоты дискретизации в 84 цикла для 18 канала,
то есть для снятия значений с температурного сенсора.

-- В регистре SMPR2:

image::ADC_SMPR2.PNG[]

В SMP0 установка частоты дискретизации в 84 цикла для 0 канала,
то есть для снятия значений с потенциометра.

-- В регистре SQR1:

image::ADC_SQR1.PNG[]

В L устанавливаем длинну последовательного преобразования 2,
одно для напряжения, второе для температуры.

-- В регистре SQR3:

image::ADC_SQR3.PNG[]

В SQ1 устанавливаем первое преобразование на 0 канал для напряжения.

В SQ0 устанавливаем первое преобразование на 18 канал для температуры.

-- В регистре RCC:

image::ADC_RCC.PNG[]

В TSVREFE включаем температурный сенсор.

=== 3.3) Voltage

image::VOLTAGE.PNG[]
Рисунок 12 -- Архитектура класса Voltage

В классе Voltage метод discreteInVolt принимает значение кода из
буфера ADC и преобразовывает в напряжение.

=== 3.4)  Temper

image::TEMPER.PNG[]
Рисунок 13 -- Архитектура класса Temper

В классе Temper метод discreteInTemp принимает значение кода из
буфера ADC и преобразовывает в температуру.

=== 3.5) FilterForVolt

image::FilterForVolt.PNG[]
Рисунок 14 -- Архитектура класса FilterForVolt

Метод filteredVolt() принимает напряжение и обрабатывает его с
помощью цифрового фильтра представленного в ТЗ. В конструктор
поступают переменные dt = 50 мс по ТЗ и RC переменная, отвечающая
за время фильтрации. Выберем 50 мс, так как при таком значении
достаточно точно фильтруются данные.

=== 3.6) FilterForTemp

image::FilterForTemp.PNG[]
Рисунок 15 -- Архитектура класса FilterForTemp

Метод filteredTemp() принимает температуру и обрабатывает ее с
помощью цифрового фильтра представленного в ТЗ.

=== 3.7) SendMessageTask

image::SendMessageTask.PNG[]
Рисунок 16 -- Архитектура класса SendMessageTask

В методе Execute реализован бесконечный цикл в котром реализовано
снятие значений температуры с фильтра каждые 50 мс и напряжения с фильтра каждые
100 мс. А так же метод Send().

Метод Send в слою очередь считывает значение с USART, как только данные будут
приняты, их сравнивают. И если по аски коду входные данные начинаются
с буквы T то будет вызов метода CharTemp(), и если по аски коду входные данные начинаются
с буквы V то будет вызов метода CharVolt().

Метод CharTemp и CharVolt вызывает методы TempToString() и VoltToString() соотвественно

Методы TempToString и VoltToString берут нужые им отфильтованные значения
и преобразовывают в строку через класс FloatToString.

=== 3.8) FloatToString

image::FloatToString.PNG[]
Рисунок 17 -- Архитектура класса FloatToString

В данном классе в конструктор приходит количество знаков после запятой
при преобразовании. В методе TempToString() и VoltToString() происходит
преобразование
напряжения полученного по методу getValue() из класса
SendMessageTask в строку. Scale - количество знаков используемое
в методе toString(), а buf отвечает за строку.

=== 3.9) USART

image::USART.PNG[]
Рисунок 18 -- Архитектура класса USART

В классе метод setup() настраивает периферию USART.

-- Настройка портов А2 и А3 на альтернативный режим работы.

image::USART_MODER.PNG[]

-- Назначение портов А2 и А3 на альтернативную функцию 7.

image::USART_AFRL.PNG[]

-- Подключаем USART2 к системе тактирования APB1.

image::USART2_EN.PNG[]

-- В регисре CR1:

image::USART2_CR1.PNG[]

В OVER8 устанавливаем режим переадескритезации на 16 бит.

В IDLEIE разрешение прерывания на состоянии ожидания линии.

В М устанавливаем длинну слова 8 бит.

В PCE отключаем контроль четности.

В TE и RE включаем приемник и передатчик.

В UE включение USART2(но просывается в последнюю очередь).

-- В регисре CR2:

image::USART2_CR2.PNG[]

Очистка битов LINEN и CLKEN на запрет тактирования.

В STOP настройка длительности стоп-бита.

-- В регисре CR3:

image::USART2_CR3.PNG[]

Очистка битов SCEN и IREN соответсвенно запрещен режим Smartcard
запрещен режим IrDA.

-- В регисре SR:

image::USART2_SR.PNG[]

Бит ТС установится аппаратно, если передаче фрейма,
содержащего данные, была завершена, и если установлен бит TXE.
Будет сгенерировано прерывание, если бит TCIE=1 в регистре USART_CR1.
Бит TC очищается последовательностью операций в программе (чтение из
регистра USART_SR, за которым идет запись в регистр USART_DR). Также
бит TC может быть очищен записью в него 0. Эта очистка рекомендуется
только для обмена с несколькими буферами.

-- В регисре BRR:

image::USART2_BRR.PNG[]

Принимает скорость с внешнего генератора HSE.

Метод Recive считывает принимаемые данные в DR, а
метод Тransmit записывает в бит DR класса USART значение
напряжения или температуру посимвольно. Метод OnTransmit()
разрешает передачу.Метод OnRecive() разрешает прием.

=== 3.10) Main

В файле main.cpp производится настройка портов и объявление объектов классов и в методе main запуск задач VoltageMeasuringTask и SendVoltageTask.

Также нужна настройка портов светодиодов. Приведем алгоритм:

Алгоритм:

* Определить какой порт нужно использовать

* Подключить нужный порт к источнику частоты через регистр RCC→AHB1ENR

* Определить нужна ли какая-то специфическая скорость для конктретного порта и если да, настроить её (через регистр GPIOx_OSPEEDR)

* Определить нужна ли подтяжка и какой тип выводов надо использовать (GPIOx_PUPDR и GPIOx_OTYPER)

* Определить какие выводы портов нужно использовать как выход, а какие как вход

* Настроить нужные вывода порта на вход или выход (через регистр GPIOE→MODER)


Сначала подключим порт А к шине тактирования через регистр RCC_AHB1ENR.

image::GPIOAEN.PNG[]

Произведем настройку 5-ой линии порта А.

Есть несколько режимов скорости порта. В нашей работе достаточно 400 кГц,
поэтому ставим по умолчанию Low speed.

image::OSPEEDR.PNG[]

Сделаем подтяжку резистора на 5 линию порта, чтобы не генерировать ложные
переходы из-за наводки или шумов. Подтяжка обычно делается к 0 или к 1.
Устанавливаем в бите значение 01 (Pull-up).

image::PUPDR.PNG[]

Выбираем тип вывода (через регистр GPIOx_OTYPER →OT5)
двухтактный повторитель Push-Pull.

image::OT.PNG[]

== 4) Результат работы программы

Первый запрос напряжения представлен ниже:

image::РезНапр.PNG[]

Второй запрос температуры:

image::РезТемп.PNG[]

Повторые запросы температуры и напряжения:

image::РезНапрТемп.PNG[]

*Вывод:* По полученным результатом стоит отметить что первые измерения немного отличаются от реальных
из-за фильтров, но последующие имеют уже отличную точность. Напряжение на потенциометре замеренное
вольтметром состовляет 3.29в, а расчитанное 3.29в. Температура окружающей среды замеренное термопарой
24.7 градуса, а расчитанное 24.880 градуса. Так же стоит отметить, что при выстовлении ручкой потенциометра
другого напряжения, так же точность остается высокой.








